<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分治法-Divide and Conquer]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%88%86%E6%B2%BB%E6%B3%95-Divide%20and%20Conquer%2F</url>
    <content type="text"><![CDATA[分治法就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 分治法典型应用 快速排序(QuickSort) 归并排序(MergeSort) 统计逆序数(CountingInversion) 平面最近点对(ClosestPair) 注意: 蛮力算法处理达到多项式时间的问题用分治法可以有效地降低处理时间。例如：用蛮力算法解决ClosestPair问题时间复杂度为$ O(n^2) $，而采用分治法时间复杂度可以降低为O(nlogn)。 结合随机抽样的分治法也可以有效的降低时间复杂度。 分治法的三大步骤 Divide： 将原问题划分为多个子问题 Conquer： 采用递归方法解决所划分的子问题 Combine： 将子问题的解合并成为原始问题的解 具体方法要看能否采用分治的方法来解决所遇到的问题，首要的思路就是要看问题的输入以及输出。首先要观察问题的输入部分，看是否能够将原始问题分解为具有相同结构但是更小的子问题。通常问题的输入部分如果是以下集中数据结构的话是很容易将原始问题分解为子问题的。 n个元素的数组 矩阵 n个元素的集和 树 有向无环图 普通图 接下来要观察问题的输出部分，想办法将容易求解出的子问题的解组合构成原问题的解。 分治法应用实例排序问题INPUT: An array of n integers, denoted as A[0..n-1];OUTPUT: The elements of A in increasing order. 插入排序将数组A[0..n-1]划分成为n-1长度的数组A[0..n-1]和一个元素：很容易可以看出A[0..n-2]与A[0..n-1]结构形式相同就是数组大小元素数量不同；因此将A[0..n-2]进行排序就构成了原问题的子问题。我们用分治的方法对A[0..n-2]进行排序最终就可以将原问题A[0..n-1]进行排序。插入排序的基本思想即为想要将A[0..n-1]进行排序，就是要将元素A[n-1]放入已经排好序的A[0..n-2]个元素之中，这可以通过将A[n-1]与已经排好序的A[0..n-2]数组中所有的元素进行对比插入即可。插入排序伪代码：12345678910InsertionSort(A, n)for j=0 to n-1 do key = A[j]; i=j-1; while i&gt;=0 and A[i]&gt;key do A[i+1]=A[i]; i--; end while A[i+1]=key;end for 操作过程示例图如下：插入排序时间复杂度$$ T(n)=T(n-1)+O(n)=O(n^2) $$由于子问题的规模减小过于缓慢（一个一个元素的递减），导致产生二次方时间复杂度。 归并排序为了纠正上面的不足，在归并排序中我们将原始数组$A[0..n-1]$二分成两个数组$A[0..n/2-1]$和$A[n/2..n-1]$，所划分得到的两个数组与原数组都有相同的形式，但是规模更小、缩减速度更快。因此将$A[0..n/2-1]$和$A[n/2..n-1]$进行排序构成了原问题的两个子问题。我们可以通过应用分治法将划分的两个子数组进行排序而后达到将原问题排序的目的。归并排序伪代码：12345678MergeSort(A,l,r)//将数组A[l..r]中的元素进行排序if l&lt;r then m=(l+r)/2;//m denotes the middle point MergeSort(A,l,m); MergeSort(A,m+1,r); Merge(A,l,m,r); //Combining the sorted arraysend if 123456789101112Merge(A,l,m,r)//Merge A[l..m] (denoted as L) and A[m + 1..r] (denoted as R).i = 0; j = 0;for k = l to r do if L[i] &lt; R[j] then A[k] = L[i]; i++; else A[k] = R[j]; j++; end ifend for 归并排序时间复杂度归并排序各部分操作所用时间如下图所示：$$T(n)=O(nlogn)$$ 归并排序应用-逆序数对统计(CountingInversion)CountingInversion problemINPUT: An array A[0..n] with n distinct numbers;OUTPUT: the number of inversions. A pair of indices i and j constitutes an inversion if i &lt; j but A[i] &gt; A[j]. 倘若采用蛮力的解决方法，给定一个元素再遍历整个数组寻找在本元素之前但是大于本元素的元素个数可想而知时间复杂度为$O(n^2)$.这里我们用分治法来解决这个问题。 Divide:将数组A二分成为两个数组A[0..n/2]和A[n/2..n-1]，可以通过分别统计两个子数组的逆序数对就可以知道原数组的总的逆序数对。 Conquer:通过回调递归来统计各个子问题（子数组）的逆序数对。 Combine:如果二分的两个子数组没有一定结构与蛮力方法比起来没有任何区别，所以要将每一个子数组进行排序后再进行求逆序数对，这样可以有效地降低时间复杂度。 CountingInversion伪代码如下：1234567891011121314151617181920Sort-and-Count(A)Divide A into two sub-sequences L and R;(RC_L,L) = Sort-and-Count(L);(RC_R,R) = Sort-and-Count(R);(C,A) = Merge-and-Count(L,R);return (RC = RCL + RCR + C;A);Merge-and-Count(L,R)RC=0;i=0;j=0;for k = 0 to ∥L∥ + ∥R∥-1 do if L[i] &gt; R[j] then A[k] = R[j]; j++; RC+=(∥L∥-i); else A[k] = L[i]; i++; end ifend forreturn (RC,A); 时间复杂度该程序就是在归并排序的基础上进行处理，时间复杂度就是归并排序的时间复杂度：$$T(n) = 2T(n/2)+O(n)=O(nlogn)$$ 快速排序上边给出的排序算法是将数组依据下标进行二分，快速排序是采用用元素数值来进行二分，大于该值的在左边小于该值的在该值右边。QuickSort伪代码：12345678910QuickSort(A)R = &#123;&#125;; L = &#123;&#125;;Choose a pivot A[j] uniformly at random;for i = 0 to n-1 do Put A[i] in L if A[i] &lt; A[j]; Put A[i] in R if A[i] &gt; A[j];end forQuickSort(L);QuickSort(R);Output L, then A[j], then R; Lomuto’s in-place algorithm思路即为将元素交换位置，使得满足A[l。。i -1] &lt; pivot和A[i..j-1]&gt;=pivot。1234567891011121314151617QuickSort(A,l,r)if l &lt; r then p =Partition(A,l,r) //Use A[r] as pivot; QuickSort(A,l,p-1); QuickSort(A,p+1,r);end if//-----------------------Partition(A,l,r)pivot=A[r]; i = l;for j = l to r-1 do if A[j] &lt; pivot then Swap A[i] with A[j]; i++; end ifend forSwap A[i] with A[r]; //Put pivot in its correct positionreturn i; 快速排序采用的随机确定枢纽元素很简单也很高效。时间复杂度 Worst case:每一次迭代都是选择的最小或者最大的元素作为枢纽元素。子问题的规模大小呈线性递减。$$T(n)=T(n-1)+O(n)=O(n^2)$$ Best case:每一次迭代都是恰好选择中位数作为枢纽元素。子问题的规模呈指数递减。$$T(n)=2T(n/2)+O(n)=O(nlogn)$$ Most case:大多数情况下都是与中位数比较接近。所以时间复杂度仍为：$$T(n)=O(nlogn)$$ 综上，我们可以知道对于快速排序来说，好的枢纽元素的选择至关重要，原始的QuickSort算法并不稳定，接下来对此算法进行改进。 快速排序改进我们知道快速排序的枢纽元素越接近中位数排序效果就越好，所以这里就加条件进行限制，使得所划分的元素最终左右两侧的元素数量不能小于整个数组长度的$1\/4$。这样可以有效的避免出现子问题（子数组）线性递减的情况。伪代码如下123456789101112131415ModifiedQuickSort(A)while TRUE do Choose a pivot A[j] uniformly at random; L = &#123;&#125;; R = &#123;&#125;; for i = 0 to n-1 do Put A[i] in L if A[i] &lt; A[j]; Put A[i] in R if A[i] &gt; A[j]; end for if ∥L∥ &gt;= n/4 and ∥R∥ &lt;= n then break; //A xed proportion of elements fall both below and above the pivot; end ifend whileModifiedQuickSort(L);ModifiedQuickSort(R);Output L, then A[j], and finally R; 以上改进算法虽然避免了出现子问题先行递减的情况，但是加了循环，如果不能够满足条件就会一直循环，所以相比于原快速排序要慢。 查找问题快速排序的应用-查找数组中第k小的元素Select the k-th smallest items in an arrayINPUT: An array A[0..n] and a number k&lt;n;OUTPUT: The k-th smallest item in general case (or the median of A as a special case). 当所给的数k很小的时候很简单，但是当k恰好为数组长度的中位数的时候就不那么简单了。要想找到第k小的值通常我们的做法就是将数组排序，排序过程的时间复杂度为$O(nlogn)$。通过应用分而治之的思想我们可以找到一个更加快速的解决方法。其采用了折半查找的方法，通过不断对半缩小查找区间来加快查找速度。伪代码如下1234567891011121314151617Select（A,k）Choose an element A[i] from A as a pivot;S+ = &#123;&#125;; S- = &#123;&#125;;for all element A[j] in A do if A[j] &gt; A[i] then S+ = S+ + A[j]; else S- = S- + A[j]; end ifend forif |S-| = k - 1 then return A[i];else if |S-| &gt; k - 1 then return Select(S-; k);else return Select(S+; k - |S-|-1);end if 可运行代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;long long A[5000001];long long GetPivot(long long a[],int l,int r);long long Max_k(long long a[],int l,int r);long long GetPivot(long long a[],int l,int r)&#123; long long value = a[l]; int i,j; i = l; j = r; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;a[j]&lt;=value)&#123; --j; &#125; a[i]=a[j]; while(i&lt;j&amp;&amp;a[i]&gt;=value)&#123; ++i; &#125; a[j]=a[i]; &#125; a[j]=value; return j;&#125;long long Max_k(long long a[],int l,int r,int k)&#123; long long tmp = GetPivot(a,l,r); if(tmp==k)&#123; return a[tmp]; &#125; else if(tmp&lt;k)&#123; Max_k(a,tmp+1,r,k); &#125; else&#123; Max_k(a,l,tmp-1,k); &#125;&#125;int main()&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;A[i]); &#125; long long max_k = Max_k(A,0,n-1,k-1); printf("%lld\n",A[k-1]); return 0;&#125; 与前面所学的快速排序不同这里的折半查找只需要考虑其中一个子问题即可，不需要遍历所有的子问题，所以此方法所需的时间还要少。 平面最小距离点对ClosestPair problemINPUT: n points in a plane;OUTPUT: The pair with the least Euclidean distance. 如下图所示： 1D case: 通过一次快速排序即可轻松解决，时间复杂度为$O(nlogn)$。 2D case: 蛮力方法即为遍历所有点对，求出其最小点对距离值，当然时间复杂度即为$O(n^2)$。存不存在小于时间复杂度$O(n^2)$的方法就能查找出平面上的最小距离点对呢？答案是肯定的，采用分而治之的思想就能有效的降低时间复杂度。 Divide：将平面划分为左右两半，每一半平面内的点数目相同。（这是很容易实现的，只需要将平面点按照$x$坐标排序，然后对半评分即可）。 Conquer: 分别找出两部分平面中最小的点对距离。 combine: 考虑一个点在左半边另一个点在右半边的情况，然后与前面找到的两个字问题最小点对距离进行对比即可。 在求边界上最小点对距离时可以观察到，我们只需遍历在边界上的一条满足距离的条带内的点对距离即可。这个矩形窄带的宽度即为左右两部分平面所查找出的两个最小点对距离的最小值。另外，$y$轴方向同样也满足这一道理。为消除不必要的计算时间我们规定只需将某一点对比在以$y$轴排序的基础上紧接其后的11个点即可，而不必与窄带中所有点对比求距离。伪代码如下：1234567891011ClosestPair(pl,...,pr)//To find the closest points within (pl,...,pr). Here we assume that pl,...,pr have already been sorted according to x-coordinate;if r - l == 1 then return d(pl,pr);end ifUse the x-coordinate of p&#123;(l+r)/2&#125;to divide pl,...,pr into two halves;S1 = ClosestPair(LeftHalf);S2 = ClosestPair(RightHalf);S = min(S1; S2);Sort points within the 2S wide strip by y -coordinate;Scan points in y-order and calculate distance between each point with its next 11 neighbors. Update S if nding a distance less than S; 可运行代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;float.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;struct Point&#123; double x, y;&#125;;Point P[100000];int cX(const void* a, const void* b)&#123; Point *p1 = (Point *)a, *p2 = (Point *)b; return (p1-&gt;x - p2-&gt;x);&#125;int cY(const void* a, const void* b)&#123; Point *p1 = (Point *)a, *p2 = (Point *)b; return (p1-&gt;y - p2-&gt;y);&#125;double Dist(Point p1, Point p2)&#123; return sqrt( (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));&#125;double bF(Point P[], int n)&#123; double min = FLT_MAX; for (int i = 0; i &lt; n; ++i) for (int j = i+1; j &lt; n; ++j) if (Dist(P[i], P[j]) &lt; min) min = Dist(P[i], P[j]); return min;&#125;double Min(double x, double y)&#123; return (x &lt; y)? x : y;&#125;double stripClosest(Point strip[], int size, double d)&#123; double Min = d; qsort(strip, size, sizeof(Point), cY); for (int i = 0; i &lt; size; ++i) for (int j = i+1; j &lt; size &amp;&amp; (strip[j].y - strip[i].y) &lt; Min; ++j) if (Dist(strip[i],strip[j]) &lt; Min) Min = Dist(strip[i], strip[j]); return Min;&#125;double closestUtil(Point P[], int n)&#123; if (n &lt;= 3) return bF(P, n); int mid = n/2; Point midPoint = P[mid]; double dl = closestUtil(P, mid); double dr = closestUtil(P + mid, n-mid); double d = Min(dl, dr); Point strip[n]; int j = 0; for (int i = 0; i &lt; n; i++) if (abs(P[i].x - midPoint.x) &lt; d) strip[j] = P[i], j++; return Min(d, stripClosest(strip, j, d) );&#125;double closest(Point P[], int n)&#123; qsort(P, n, sizeof(Point), cX); return closestUtil(P, n);&#125;int main()&#123; int n; scanf("%d",&amp;n); if(n&lt;2) return -1; for(int i=0;i&lt;n;i++) &#123; scanf("%lf%lf",&amp;P[i].x,&amp;P[i].y); &#125; printf("%.2lf\n", closest(P, n)); return 0;&#125; 算法时间复杂度为：$$T(n)=2T(n/2)+O(n)=O(nlogn)$$ 具体流程图示如下：]]></content>
      <categories>
        <category>算法</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
