<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode习题-数组</title>
    <url>/2020/03/01/LeetCode%E4%B9%A0%E9%A2%98-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="1-从排序数组中删除重复项"><a href="#1-从排序数组中删除重复项" class="headerlink" title="1.从排序数组中删除重复项"></a>1.从排序数组中删除重复项</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用$O(1)$额外空间的条件下完成。</p>
<p>示例1：<br><div class="note default"><p>给定数组 $nums$ = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 $nums$ 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p></div></p>
<p>示例2：<br><div class="note default"><p>给定 $nums$ = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 $nums$ 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p></div></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        int number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[number] != nums[i]) &#123;</span><br><span class="line">                number ++;</span><br><span class="line">                nums[number] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (number + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-Dynamic Programming</title>
    <url>/2020/02/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic%20Programming/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>动态规划算法</strong>的思想和分治算法类似，基本思想也是将待求问题分解成若干个子问题，先求解子问题最优解，然后那个这些子问题的解得到原问题的解。因此，动态规划算法也是自底向上进行计算的，每一个子问题可以看成是一个状态，关键是找到状态转移方程，这样才能从一个子问题进一步推得原问题的解。</p>
</blockquote>
<h1 id="动态规划典型应用"><a href="#动态规划典型应用" class="headerlink" title="动态规划典型应用"></a>动态规划典型应用</h1><ul>
<li><strong>矩阵链式相乘(MatrixChainMultiplication)</strong></li>
<li><strong>背包问题(Knapsack)</strong></li>
<li><strong>序列比对(Sequence Alignment)</strong></li>
<li><strong>最短路径问题(Shortest Path)</strong></li>
</ul>
<h1 id="动态规划算法与分治算法的联系"><a href="#动态规划算法与分治算法的联系" class="headerlink" title="动态规划算法与分治算法的联系"></a>动态规划算法与分治算法的联系</h1><p>动态规划算法通常适用于具有以下性质的优化问题：</p>
<ol>
<li>原问题可以分解为较小的子问题</li>
<li>子问题之间的递归具有最优子结构属性，即可以通过组合子问题的最优解来计算原始问题的最优解</li>
</ol>
<p>为了找到并确定有意义的递归，关键步骤之一是定义子问题的适当常规形式。 为此，通常将解决过程描述为一个多阶段决策过程。<br>与一般的分而治之框架不同，动态编程算法通常会枚举所有可能的划分策略。 另外，<strong>通过“编程”避免了重复计算常见子问题</strong>。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分治法-Divide and Conquer</title>
    <url>/2019/01/25/%E5%88%86%E6%B2%BB%E6%B3%95-Divide%20and%20Conquer/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>分治法</strong>就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
</blockquote>
<h1 id="分治法典型应用"><a href="#分治法典型应用" class="headerlink" title="分治法典型应用"></a>分治法典型应用</h1><ul>
<li><strong>快速排序(QuickSort)</strong></li>
<li><strong>归并排序(MergeSort)</strong></li>
<li><strong>统计逆序数(CountingInversion)</strong></li>
<li><strong>平面最近点对(ClosestPair)</strong></li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li>蛮力算法处理达到多项式时间的问题用分治法可以有效地降低处理时间。例如：用蛮力算法解决ClosestPair问题时间复杂度为$ O(n^2) $，而采用分治法时间复杂度可以降低为O(nlogn)。</li>
<li>结合随机抽样的分治法也可以有效的降低时间复杂度。</li>
</ul>
<h1 id="分治法的三大步骤"><a href="#分治法的三大步骤" class="headerlink" title="分治法的三大步骤"></a>分治法的三大步骤</h1><ol>
<li><strong>Divide：</strong> 将原问题划分为多个子问题</li>
<li><strong>Conquer：</strong> 采用递归方法解决所划分的子问题</li>
<li><strong>Combine：</strong> 将子问题的解合并成为原始问题的解</li>
</ol>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>要看能否采用分治的方法来解决所遇到的问题，首要的思路就是要看问题的输入以及输出。<br>首先要观察问题的输入部分，看是否能够将原始问题分解为具有相同结构但是更小的子问题。通常问题的输入部分如果是以下集中数据结构的话是很容易将原始问题分解为子问题的。</p>
<ul>
<li>n个元素的数组</li>
<li>矩阵</li>
<li>n个元素的集和</li>
<li>树</li>
<li>有向无环图</li>
<li>普通图</li>
</ul>
<p>接下来要观察问题的输出部分，想办法将容易求解出的子问题的解组合构成原问题的解。</p>
<h1 id="分治法应用实例"><a href="#分治法应用实例" class="headerlink" title="分治法应用实例"></a>分治法应用实例</h1><h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><div class="note default"><p><strong>INPUT:</strong> An array of n integers, denoted as A[0..n-1];<br><strong>OUTPUT:</strong> The elements of A in increasing order.</p></div>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将数组A[0..n-1]划分成为n-1长度的数组A[0..n-1]和一个元素：很容易可以看出A[0..n-2]与A[0..n-1]结构形式相同就是数组大小元素数量不同；因此将A[0..n-2]进行排序就构成了原问题的子问题。我们用分治的方法<br>对A[0..n-2]进行排序最终就可以将原问题A[0..n-1]进行排序。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128165634170.png" alt="原问题与子问题"><br><strong>插入排序</strong>的基本思想即为想要将A[0..n-1]进行排序，就是要将元素A[n-1]放入已经排好序的A[0..n-2]个元素之中，这可以通过将A[n-1]与已经排好序的A[0..n-2]数组中所有的元素进行对比插入即可。<br><strong>插入排序伪代码：</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">InsertionSort(A, n)</span><br><span class="line"><span class="keyword">for</span> j=<span class="number">0</span> to n<span class="number">-1</span> do</span><br><span class="line">  key = A[j];</span><br><span class="line">  i=j<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> A[i]&gt;key do</span><br><span class="line">    A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">    i--;</span><br><span class="line">  end <span class="keyword">while</span></span><br><span class="line">  A[i+<span class="number">1</span>]=key;</span><br><span class="line">end <span class="keyword">for</span></span><br></pre></td></tr></table></figure></p>
<p>操作过程示例图如下：<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128172050106.png" alt="插入排序具体过程图示"><br><strong>插入排序时间复杂度</strong><br>$$ T(n)=T(n-1)+O(n)=O(n^2) $$<br>由于子问题的规模减小过于缓慢（一个一个元素的递减），导致产生二次方时间复杂度。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>为了纠正上面的不足，在<strong>归并排序</strong>中我们将原始数组$A[0..n-1]$二分成两个数组$A[0..n/2-1]$和$A[n/2..n-1]$，所划分得到的两个数组与原数组都有相同的形式，但是规模更小、缩减速度更快。因此将$A[0..n/2-1]$和$A[n/2..n-1]$进行排序构成了原问题的两个子问题。我们可以通过应用<strong>分治法</strong>将划分的两个子数组进行排序而后达到将原问题排序的目的。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128174110331.png" alt="归并排序二分原问题图示"><br><strong>归并排序伪代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MergeSort(A,l,r)</span><br><span class="line"><span class="comment">//将数组A[l..r]中的元素进行排序</span></span><br><span class="line"><span class="keyword">if</span> l&lt;r then</span><br><span class="line">  m=(l+r)/<span class="number">2</span>;<span class="comment">//m denotes the middle point</span></span><br><span class="line">  MergeSort(A,l,m);</span><br><span class="line">  MergeSort(A,m+<span class="number">1</span>,r);</span><br><span class="line">  Merge(A,l,m,r); <span class="comment">//Combining the sorted arrays</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Merge(A,l,m,r)</span><br><span class="line"><span class="comment">//Merge A[l..m] (denoted as L) and A[m + 1..r] (denoted as R).</span></span><br><span class="line">i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = l to r <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> L[i] &lt; R[j] then</span><br><span class="line">    A[k] = L[i];</span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    A[k] = R[j];</span><br><span class="line">    j++;</span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">for</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128175150117.png" alt="归并排序过程图示"><br><strong>归并排序时间复杂度</strong><br><strong>归并排序</strong>各部分操作所用时间如下图所示：<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128183003770.png" alt="时间复杂度"><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128183206936.png" alt="时间复杂度公式"><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128183320337.png" alt="时间复杂度计算过程"><br>$$T(n)=O(nlogn)$$</p>
<h4 id="归并排序应用-逆序数对统计-CountingInversion"><a href="#归并排序应用-逆序数对统计-CountingInversion" class="headerlink" title="归并排序应用-逆序数对统计(CountingInversion)"></a>归并排序应用-逆序数对统计(CountingInversion)</h4><div class="note default"><p><strong>CountingInversion problem</strong><br><strong>INPUT:</strong> An array A[0..n] with n distinct numbers;<br><strong>OUTPUT:</strong> the number of inversions. A pair of indices i and j constitutes an inversion if i &lt; j but A[i] &gt; A[j].</p></div>
<p>倘若采用<strong>蛮力</strong>的解决方法，给定一个元素再遍历整个数组寻找在本元素之前但是大于本元素的元素个数可想而知时间复杂度为$O(n^2)$.<br>这里我们用<strong>分治法</strong>来解决这个问题。</p>
<ol>
<li><strong>Divide:</strong>将数组A二分成为两个数组A[0..n/2]和A[n/2..n-1]，可以通过分别统计两个子数组的逆序数对就可以知道原数组的总的逆序数对。</li>
<li><strong>Conquer:</strong>通过回调递归来统计各个子问题（子数组）的逆序数对。</li>
<li><strong>Combine:</strong>如果二分的两个子数组没有一定结构与<strong>蛮力</strong>方法比起来没有任何区别，所以要将每一个子数组进行排序后再进行求逆序数对，这样可以有效地降低时间复杂度。</li>
</ol>
<p><strong>CountingInversion伪代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sort-<span class="keyword">and</span>-Count(A)</span><br><span class="line">Divide A into two sub-sequences L <span class="keyword">and</span> R;</span><br><span class="line">(RC_L,L) = Sort-<span class="keyword">and</span>-Count(L);</span><br><span class="line">(RC_R,R) = Sort-<span class="keyword">and</span>-Count(R);</span><br><span class="line">(C,A) = Merge-<span class="keyword">and</span>-Count(L,R);</span><br><span class="line"><span class="keyword">return</span> (RC = RCL + RCR + C;A);</span><br><span class="line"></span><br><span class="line">Merge-<span class="keyword">and</span>-Count(L,R)</span><br><span class="line">RC=<span class="number">0</span>;i=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">0</span> to ∥L∥ + ∥R∥<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> L[i] &gt; R[j] then</span><br><span class="line">    A[k] = R[j];</span><br><span class="line">    j++;</span><br><span class="line">    RC+=(∥L∥-i);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    A[k] = L[i];</span><br><span class="line">    i++;</span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">return</span> (RC,A);</span><br></pre></td></tr></table></figure></p>
<p><strong>时间复杂度</strong><br>该程序就是在归并排序的基础上进行处理，时间复杂度就是<strong>归并排序</strong>的时间复杂度：<br>$$T(n) = 2T(n/2)+O(n)=O(nlogn)$$</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>上边给出的排序算法是将数组依据下标进行二分，<strong>快速排序</strong>是采用用<strong>元素数值</strong>来进行二分，大于该值的在左边小于该值的在该值右边。<br><strong>QuickSort伪代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QuickSort(A)</span><br><span class="line">R = &#123;&#125;; L = &#123;&#125;;</span><br><span class="line">Choose a pivot A[j] uniformly at <span class="built_in">random</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">  Put A[i] in L <span class="keyword">if</span> A[i] &lt; A[j];</span><br><span class="line">  Put A[i] in R <span class="keyword">if</span> A[i] &gt; A[j];</span><br><span class="line"><span class="built_in">end</span> <span class="keyword">for</span></span><br><span class="line">QuickSort(L);</span><br><span class="line">QuickSort(R);</span><br><span class="line">Output L, then A[j], then R;</span><br></pre></td></tr></table></figure></p>
<p><strong>Lomuto’s in-place algorithm</strong><br><strong>思路</strong>即为将元素交换位置，使得满足A[l。。i -1] &lt; pivot和A[i..j-1]&gt;=pivot。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128222047876.png" alt="图示"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QuickSort(A,l,r)</span><br><span class="line"><span class="keyword">if</span> l &lt; r then</span><br><span class="line">  p =Partition(A,l,r) <span class="comment">//Use A[r] as pivot;</span></span><br><span class="line">  QuickSort(A,l,p<span class="number">-1</span>);</span><br><span class="line">  QuickSort(A,p+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">Partition(A,l,r)</span><br><span class="line">pivot=A[r]; i = l;</span><br><span class="line"><span class="keyword">for</span> j = l to r<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> A[j] &lt; pivot then</span><br><span class="line">    Swap A[i] with A[j];</span><br><span class="line">    i++;</span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">for</span></span><br><span class="line">Swap A[i] with A[r]; <span class="comment">//Put pivot in its correct position</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure></p>
<p><strong>快速排序</strong>采用的随机确定<strong>枢纽元素</strong>很简单也很高效。<br><strong>时间复杂度</strong></p>
<ul>
<li><strong>Worst case:</strong>每一次迭代都是选择的最小或者最大的元素作为<strong>枢纽元素</strong>。子问题的规模大小呈线性递减。<br>$$T(n)=T(n-1)+O(n)=O(n^2)$$</li>
<li><strong>Best case:</strong>每一次迭代都是恰好选择中位数作为<strong>枢纽元素</strong>。子问题的规模呈指数递减。<br>$$T(n)=2T(n/2)+O(n)=O(nlogn)$$</li>
<li><strong>Most case:</strong>大多数情况下都是与中位数比较接近。所以时间复杂度仍为：<br>$$T(n)=O(nlogn)$$</li>
</ul>
<p>综上，我们可以知道对于<strong>快速排序</strong>来说，好的<strong>枢纽元素</strong>的选择至关重要，原始的QuickSort算法并不稳定，接下来对此算法进行改进。</p>
<h3 id="快速排序改进"><a href="#快速排序改进" class="headerlink" title="快速排序改进"></a>快速排序改进</h3><p>我们知道<strong>快速排序</strong>的<strong>枢纽元素</strong>越接近中位数排序效果就越好，所以这里就加条件进行限制，使得所划分的元素最终左右两侧的元素数量不能小于整个数组长度的$1\/4$。这样可以有效的避免出现子问题（子数组）线性递减的情况。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190128215718724.png" alt="best pivot"><br><strong>伪代码如下</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ModifiedQuickSort(A)</span><br><span class="line"><span class="keyword">while</span> TRUE <span class="keyword">do</span></span><br><span class="line">  Choose a pivot A[j] uniformly at <span class="built_in">random</span>;</span><br><span class="line">  L = &#123;&#125;; R = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    Put A[i] in L <span class="keyword">if</span> A[i] &lt; A[j];</span><br><span class="line">    Put A[i] in R <span class="keyword">if</span> A[i] &gt; A[j];</span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">for</span></span><br><span class="line">  <span class="keyword">if</span> ∥L∥ &gt;= n/<span class="number">4</span> <span class="keyword">and</span> ∥R∥ &lt;= n then</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//Axed proportion of elements fall both below and above the pivot;</span></span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">while</span></span><br><span class="line">ModifiedQuickSort(L);</span><br><span class="line">ModifiedQuickSort(R);</span><br><span class="line">Output L, then A[j], <span class="keyword">and</span>finally R;</span><br></pre></td></tr></table></figure></p>
<p>以上改进算法虽然避免了出现子问题先行递减的情况，但是加了循环，如果不能够满足条件就会一直循环，所以相比于<strong>原快速排序</strong>要慢。</p>
<h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><h3 id="快速排序的应用-查找数组中第k小的元素"><a href="#快速排序的应用-查找数组中第k小的元素" class="headerlink" title="快速排序的应用-查找数组中第k小的元素"></a>快速排序的应用-查找数组中第k小的元素</h3><div class="note default"><p><strong>Select the k-th smallest items in an array</strong><br><strong>INPUT:</strong> An array A[0..n] and a number k&lt;n;<br><strong>OUTPUT:</strong> The k-th smallest item in general case (or the median of A as a special case).</p></div>
<p>当所给的数k很小的时候很简单，但是当k恰好为数组长度的中位数的时候就不那么简单了。要想找到第k小的值通常我们的做法就是将数组排序，排序过程的时间复杂度为$O(nlogn)$。通过应用分而治之的思想我们可以找到一个更加快速的解决方法。<br>其采用了折半查找的方法，通过不断对半缩小查找区间来加快查找速度。<br><strong>伪代码如下</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Select（A,k）</span><br><span class="line">Choose an element A[i] from A as a pivot;</span><br><span class="line">S+ = &#123;&#125;; S- = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> all element A[j] in A <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> A[j] &gt; A[i] then</span><br><span class="line">    S+ = S+ + A[j];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    S- = S- + A[j];</span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">if</span> |S-| = k - <span class="number">1</span> then</span><br><span class="line">  <span class="keyword">return</span> A[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> |S-| &gt; k - <span class="number">1</span> then</span><br><span class="line">  <span class="keyword">return</span> Select(S-; k);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> Select(S+; k - |S-|<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p><strong>可运行代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">5000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">GetPivot</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Max_k</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">GetPivot</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = a[l];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i = l;</span><br><span class="line">    j = r;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&lt;=value)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&gt;=value)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[j]=value;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Max_k</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = GetPivot(a,l,r);</span><br><span class="line">    <span class="keyword">if</span>(tmp==k)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;k)&#123;</span><br><span class="line">        Max_k(a,tmp+<span class="number">1</span>,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Max_k(a,l,tmp<span class="number">-1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_k = Max_k(A,<span class="number">0</span>,n<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,A[k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与前面所学的快速排序不同这里的折半查找只需要考虑其中一个子问题即可，不需要遍历所有的子问题，所以此方法所需的时间还要少。</p>
<h2 id="平面最小距离点对"><a href="#平面最小距离点对" class="headerlink" title="平面最小距离点对"></a>平面最小距离点对</h2><div class="note default"><p><strong>ClosestPair problem</strong><br><strong>INPUT:</strong> n points in a plane;<br><strong>OUTPUT:</strong> The pair with the least Euclidean distance.</p></div>
<p><strong>如下图所示：</strong><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225203719922.png" alt="ClosestPair"></p>
<ul>
<li><strong>1D case:</strong> 通过一次快速排序即可轻松解决，时间复杂度为$O(nlogn)$。</li>
<li><strong>2D case:</strong> 蛮力方法即为遍历所有点对，求出其最小点对距离值，当然时间复杂度即为$O(n^2)$。<br><strong>存不存在小于时间复杂度$O(n^2)$的方法就能查找出平面上的最小距离点对呢？答案是肯定的，采用分而治之的思想就能有效的降低时间复杂度。</strong></li>
</ul>
<ol>
<li><strong>Divide：</strong>将平面划分为左右两半，每一半平面内的点数目相同。（这是很容易实现的，只需要将平面点按照$x$坐标排序，然后对半评分即可）。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225204921163.png" alt="divide"></li>
<li><strong>Conquer:</strong> 分别找出两部分平面中最小的点对距离。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225205157747.png" alt="conquer"></li>
<li><strong>combine:</strong> 考虑一个点在左半边另一个点在右半边的情况，然后与前面找到的两个字问题最小点对距离进行对比即可。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225205548905.png" alt="combine"></li>
</ol>
<p>在求边界上最小点对距离时可以观察到，我们只需遍历在边界上的一条满足距离的条带内的点对距离即可。这个矩形窄带的宽度即为左右两部分平面所查找出的两个最小点对距离的最小值。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225210214495.png" alt="observation"><br>另外，$y$轴方向同样也满足这一道理。为消除不必要的计算时间我们规定只需将某一点对比在以$y$轴排序的基础上紧接其后的11个点即可，而不必与窄带中所有点对比求距离。<br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-2019022521074168.png" alt="11"><br><strong>伪代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClosestPair(pl,...,pr)</span><br><span class="line"><span class="comment">//Tofind the closest points within (pl,...,pr). Here we assume that pl,...,pr have already been sorted according to x-coordinate;</span></span><br><span class="line"><span class="keyword">if</span> r - l == <span class="number">1</span> then</span><br><span class="line">  <span class="keyword">return</span> d(pl,pr);</span><br><span class="line"><span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line">Use the x-coordinate of p&#123;(l+r)/<span class="number">2</span>&#125;to divide pl,...,pr into two halves;</span><br><span class="line">S1 = ClosestPair(LeftHalf);</span><br><span class="line">S2 = ClosestPair(RightHalf);</span><br><span class="line">S = <span class="built_in">min</span>(S1; S2);</span><br><span class="line">Sort points within the <span class="number">2</span>S wide strip by y -coordinate;</span><br><span class="line">Scan points in y-order <span class="keyword">and</span> calculate distance between each <span class="built_in">point</span> with its next <span class="number">11</span> neighbors. Update S <span class="keyword">if</span>nding a distance less than S;</span><br></pre></td></tr></table></figure></p>
<p><strong>可运行代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cX</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point *p1 = (Point *)a, *p2 = (Point *)b;</span><br><span class="line">    <span class="keyword">return</span> (p1-&gt;x - p2-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cY</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point *p1 = (Point *)a, *p2 = (Point *)b;</span><br><span class="line">    <span class="keyword">return</span> (p1-&gt;y - p2-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist</span><span class="params">(Point p1, Point p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>( (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bF</span><span class="params">(Point P[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">min</span> = FLT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (Dist(P[i], P[j]) &lt; <span class="built_in">min</span>)</span><br><span class="line">                <span class="built_in">min</span> = Dist(P[i], P[j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Min</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stripClosest</span><span class="params">(Point strip[], <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Min = d;</span><br><span class="line">    qsort(strip, <span class="built_in">size</span>, <span class="keyword">sizeof</span>(Point), cY);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="built_in">size</span> &amp;&amp; (strip[j].y - strip[i].y) &lt; Min; ++j)</span><br><span class="line">            <span class="keyword">if</span> (Dist(strip[i],strip[j]) &lt; Min)</span><br><span class="line">                Min = Dist(strip[i], strip[j]);</span><br><span class="line">    <span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closestUtil</span><span class="params">(Point P[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> bF(P, n);</span><br><span class="line">    <span class="keyword">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line">    Point midPoint = P[mid];</span><br><span class="line">    <span class="keyword">double</span> dl = closestUtil(P, mid);</span><br><span class="line">    <span class="keyword">double</span> dr = closestUtil(P + mid, n-mid);</span><br><span class="line">    <span class="keyword">double</span> d = Min(dl, dr);</span><br><span class="line"></span><br><span class="line">    Point strip[n];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(P[i].x - midPoint.x) &lt; d)</span><br><span class="line">            strip[j] = P[i], j++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Min(d, stripClosest(strip, j, d) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point P[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qsort(P, n, <span class="keyword">sizeof</span>(Point), cX);</span><br><span class="line">    <span class="keyword">return</span> closestUtil(P, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;P[i].x,&amp;P[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, closest(P, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>算法时间复杂度为：</strong><br>$$T(n)=2T(n/2)+O(n)=O(nlogn)$$</p>
<p><strong>具体流程图示如下：</strong><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225211701102.png" alt="1"><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225211848917.png" alt="2"><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225211943716.png" alt="3"><br><img src="/2019/01/25/分治法-Divide and Conquer/markdown-img-paste-20190225212042137.png" alt="4"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
